// 2019 Team AobaZero
// This source code is in the public domain.
// yss_int.h
	 			//  ou   fu   ky   ke   gi   ki   ka   hi
int kati[16]   = {   0, 100, 330, 350, 500, 550, 720, 850,	// 香以上を100点、銀を40点、角を30点、飛を20点下げる
				  9999, 420, 530, 540, 530,   0, 960,1110  };

int n_kati[16] = {   0, 320, 200, 190,  30,   0, 240, 260,
				     0,   0,   0,   0,   0,   0,   0,   0  };

int k_kati[16] = {   0, 200, 660, 700,1000,1100,1440,1700,
				 19998, 520, 860, 890,1030,   0,1680,1960  };

int m_kati[8][32] = { { 0 },				   // fu   15
				 {   0, 115, 225, 325, 415, 495, 560, 620, 680, 740,
				   800, 860, 920, 980,1040,1100,1160,1220,1280      },
				 {   0, 380, 740,1050,1300 },  // yari 50,30,-20, -80  4枚持っても意味ないので
				 {   0, 410, 790,1090,1310 },  // kei  60,30,-50,-130 
				 {   0, 580,1130,1630,2080 },  // gin  80,50,  0, -50  金銀は4枚あってもそれほど下がらない？
				 {   0, 640,1240,1790,2290 },  // kin  90,50,  0, -50
				 {   0, 960,1860           },  // kaku 240,180 
				 {   0,1120,2160           } };// hi   270,190



int totta_koma[18][16];		// 駒を取ったときに、持駒の枚数により、＋する増分。
int utta_koma[19][8];
int m_koma_plus[18][8];		// m_kati[][n] - m_kati[][n-1];

const int z8[8] = { +0x01, +0x11, +0x10, +0x0f, -0x01, -0x11, -0x10, -0x0f };

const int oute_can[4][16] = {
/***      fu ky ke gi ki ka hi ou to ny nk ng // um ry      ***/
	{	0, 1, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1	 },
	{   0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 1, 1, 1, 0, 1, 1   },
	{   0, 0, 0, 0, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 1, 1   },
	{   0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 1, 1   }
};

const int oute_z[2][8] = {
	{	+0x10, +0x0f, +0x11, +0x01, -0x01, -0x10, -0x0f, -0x11 },
	{		0,     1,	  1,	 2,     2,     2,     3,     3 }
};

int gin_z5[5] = { +0x10, +0x11, +0x0f, -0x11, -0x0f };
int kin_z6[6] = { +0x10, +0x11, +0x0f, +0x01, -0x01, -0x10 };





unsigned int hash_ban[32][BAN_SIZE][2];


// 歩:6 香:4 桂:4 銀:4 金:4 角:3 飛:3 と通常より1bitだと多く取る。引き算だけで
// 000 000 0000 0000 0000 0000 000000
// 	飛  角  金   銀   桂   香    歩
// 100 100 1000 1000 1000 1000 100000 ... SIGN_BITS	0x9222220
//#define HASH_MOTIGOMA_SIGN_BITS 0x9222220  どれか1枚でも少ない駒があると余計なbitに1が立ち、SIGN_BITSで検出できる
const unsigned int hash_mask[3][8] = {
	/*        fu     yari      kei      gin      kin     kaku       hi */
	{ 0,0x000001,0x000040,0x000400,0x004000,0x040000, 0x400000,0x2000000 },	// value(1枚分の値)
	{ 0,0x00003f,0x0003c0,0x003c00,0x03c000,0x3c0000,0x1c00000,0xe000000 }, // mask
	{ 0,       0,       6,      10,      14,      18,       22,       25 }	// shift
};
/*
1
00000000000000000000000000000001
00000000000000000000000000111111
2
00000000000000000000000001000000
00000000000000000000001111000000
3
00000000000000000000010000000000
00000000000000000011110000000000
4
00000000000000000100000000000000
00000000000000111100000000000000
5
00000000000001000000000000000000
00000000001111000000000000000000
6
00000000010000000000000000000000
00000001110000000000000000000000
7
00000010000000000000000000000000
00001110000000000000000000000000

00001001001000100010001000100000
*/
/*
const int hash_mask_shift2 =  5;
const int hash_mask_shift3 =  8;
const int hash_mask_shift4 = 11;
const int hash_mask_shift5 = 14;
const int hash_mask_shift6 = 17;
const int hash_mask_shift7 = 19;
*/
